select * from user_constraints where table_name = 'departments';

select * from user_constraints where table_name = 'employees';

drop table a;

create table a( -- 부모 테이블
    a1 int primary key,
    a2 int
);

create table b( -- 자식 테이블
    b1 varchar(10),
    a1 int,
    constraint b_a1_fk foreign key(a1) references a(a1)
);
--> 자식 테이블에 데이터가 존재하기 위해서는 부모 테이블에 먼저 데이터가 존재해야 함

INSERT INTO B VALUES('A', 1);
--> 부모 테이블에 데이터가 없어서 생기는 오류

INSERT INTO A VALUES(1, 1);

INSERT INTO B VALUES('A', 1);

SELECT * FROM A;
SELECT * FROM B;

DROP TABLE A;
--> 자식 테이블이 있는 경우 테이블 삭제 불가능

DROP TABLE B;
DROP TABLE A;
--> 자식 테이블 먼저 삭제 한 후 부모 테이블 삭제해야 함

DELETE FROM A;
--> 부모 테이블의 데이터 삭제하는 경우에는 자식 테이블의 데이터 먼저 삭제해야 함

DELETE FROM B;
DELETE FROM A;
--> FOREIGN KEY(관계)가 있는 경우에는 부모 테이블의 데이터를 삭제할 수 없음

CREATE TABLE C( -- 부모 테이블
    A1 INT PRIMARY KEY,
    A2 INT
);

-- 비식별관계
CREATE TABLE D( -- 자식 테이블
    D1 INT,
    A1 INT CONSTRAINT D_A1_FK REFERENCES C(A1) ON DELETE SET NULL
    --> 자식 테이블의 데이터는 남기고 부모 테이블의 데이터만 삭제
);

-- 식별 관계
CREATE TABLE E(
    E1 INT,
    A1 INT REFERENCES C(A1) ON DELETE CASCADE
    --> 부모 테이블의 데이터를 삭제하는 경우 자식 테이블의 데이터도 같이 삭제
);

INSERT INTO C VALUES(1,1);
INSERT INTO D VALUES(2,1);
INSERT INTO E VALUES(3,1);

SELECT * FROM C;
SELECT * FROM D;
SELECT * FROM E;

DELETE FROM C;
SELECT * FROM C;
SELECT * FROM D;
SELECT * FROM E;

DESC EMPLOYEES;
DROP TABLE EMPLOYEES;


-- 테이블 레벨로 제약조건
CREATE TABLE EMPLOYEES(
    EMPLOYEE_ID NUMBER,
    FIRST_NAME VARCHAR2(20) NOT NULL,
    LAST_NAME VARCHAR2(25) NOT NULL,
    EMAIL VARCHAR2(25),
    PHONE_NUMBER VARCHAR2(20),
    HIRE_DATE DATE DEFAULT SYSDATE,
    JOB_ID VARCHAR2(10),
    SALARY NUMBER(8,2),
    COMMISSION_PCT NUMBER(2,2),
    MANAGER_ID NUMBER(6),
    DEPARTMENT_ID NUMBER(4),
    CONSTRAINT EMP_EMPLOYEE_ID_PK1 PRIMARY KEY(EMPLOYEE_ID),
    --CONSTRAINT EMP_EMAIL_UK1 UNIQUE(EMAIL),
    CONSTRAINT EMP_DEPARTMENT_ID_FK1 FOREIGN KEY(DEPARTMENT_ID)
    REFERENCES DEPARTMENTS(DEPARTMENT_ID),
    CONSTRAINT EMP_SALARY_CK1 CHECK (SALARY > 0)
);

INSERT INTO EMPLOYEES 
VALUES(114, 'Den', 'Raphealy', 'DRAPHEAL', '515.127.4561', '2021/05/19',
        'AC_ACCOUNT', -10000, NULL, 100, 30);
        
SELECT * FROM EMPLOYEES;

ROLLBACK;

CREATE TABLE CHECKEXAM(
    CITY CHAR(10) CONSTRAINT CH_CHECKEXAM_CITY CHECK(CITY IN('서울', '대전', '강릉', '채백'))
);

INSERT INTO CHECKEXAM VALUES('서울');
INSERT INTO CHECKEXAM VALUES('춘천');

DROP TABLE CHECKCONST1;

CREATE TABLE CHECKCONST1(
    EID INT NOT NULL,
    VALUE1 INT NOT NULL,
    VALUE2 INT NOT NULL,
    NAME1 VARCHAR(10) NOT NULL,
    NAME2 VARCHAR(10) DEFAULT 'f',
    CONSTRAINT CHK_VALUE1_CK CHECK(VALUE1 BETWEEN 1 AND 10),
    CONSTRAINT CHK_NAME2_CK CHECK(NAME2 IN('a','b')),
    CONSTRAINT CHK_VALUE1_VALUE2_CK CHECK(VALUE1 < VALUE2)
);

INSERT INTO CHECKCONST1 VALUES(1, 1, 2, 'a..', 'a');
INSERT INTO CHECKCONST1 VALUES(2, 2, 2, 'a..', 'a');
INSERT INTO CHECKCONST1 VALUES(2, 2, 4, 'a..', DEFAULT);

CREATE TABLE EMP_TEST AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY FROM HR.EMPLOYEES;

DESC EMP_TEST;
SELECT * FROM EMP_TEST;

DROP TABLE DEPT80;

CREATE TABLE DEPT80 AS
SELECT EMPLOYEE_ID, LAST_NAME, SALARY * 12 ANNSAL, HIRE_DATE FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID = 80;

SELECT * FROM DEPT80;

CREATE TABLE COPY_EMP AS
SELECT * FROM HR.EMPLOYEES;

-- 모든 데이터 저장
--> NOT NULL 제약 조건과 데이터 유형까지 데이터와 같이 가지고 옴
SELECT * FROM COPY_EMP;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'COPY_EMP';

-- 테이블만 복사할 때
CREATE TABLE COPY_EMP1 AS
SELECT * FROM HR.EMPLOYEES WHERE 1 = 2;

SELECT * FROM COPY_EMP1;

SELECT * FROM EMPLOYEES;

INSERT INTO EMPLOYEES
SELECT * FROM HR.EMPLOYEES;

SELECT * FROM DEPARTMENTS;

TRUNCATE TABLE DEPARTMENTS;
DELETE FROM DEPARTMENTS;
INSERT INTO DEPARTMENTS
SELECT * FROM HR.DEPARTMENTS;

SELECT * FROM DEPARTMENTS;

DROP VIEW EMPVU80;

-- VIEW
CREATE VIEW EMPVU80 AS
SELECT EMPLOYEE_ID, LAST_NAME, SALARY FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

SELECT * FROM EMPVU80;
DESC EMPVU80;

INSERT INTO EMPLOYEES
VALUES(9999, 'Den', 'Raphealy', 'DRAPHEAL', '515.127.4561', '2021/05/19',
    'AC_ACCOUNT', 1000, NULL, 100, 80);

DROP VIEW TEST_VIEW;

CREATE VIEW TEST_VIEW AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES;

SELECT * FROM TEST_VIEW;

-- DML문 사용 가능
-- 뷰를 이용해 실제 테이블에 값 저장
-- 뷰는 테이블에 있는 데이터를 보여주는 역할
INSERT INTO TEST_VIEW
VALUES(9998, 'Soong', 'Rhee', 'RSOONG', SYSDATE, 'AC_REP', 30);

SELECT * FROM EMPLOYEES;

UPDATE TEST_VIEW
SET PHONE_NUMBER = '515.127.4561'
WHERE EMPLOYEE_ID = 9998;
--> 뷰를 통해 UPDATE를 할 경우에는 뷰를 통해 보여지는 컬럼만 가능

UPDATE TEST_VIEW
SET EMAIL = 'RMOO'
WHERE EMPLOYEE_ID = 9998;

SELECT * FROM EMPLOYEES;

DELETE FROM TEST_VIEW
WHERE EMPLOYEE_ID = 9998;

SELECT * FROM EMPLOYEES;

DROP VIEW TEST_CMP1;

CREATE VIEW TEST_CMP1 (EMP_ID, F_NAME, L_NAME, ENAME, H_DATE, J_ID, DEPT_ID) AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50;

SELECT * FROM TEST_CMP1;

DROP VIEW TEST_CMP2;

CREATE VIEW TEST_CMP2 AS
SELECT EMPLOYEE_ID E_ID, FIRST_NAME F_NAME, LAST_NAME L_NAME, EMAIL, HIRE_DATE H_DATE, 
        JOB_ID J_ID, DEPARTMENT_ID DEPT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50;

SELECT * FROM TEST_CMP2;

INSERT INTO TEST_CMP2
VALUES(9998, 'Soong', 'Rhee', 'RSOONG', SYSDATE, 'AC_REP', 30);

SELECT * FROM TEST_CMP2;
SELECT * FROM EMPLOYEES;

UPDATE TEST_CMP2
SET EMAIL = 'RMOO'
WHERE E_ID = 9998;
--> 뷰를 통해 보이지 않으면 UPDATE를 할 수 없음

DELETE FROM TEST_CMP2
WHERE E_ID = 9998;
--> 뷰를 통해 보이지 않으면 DELETE를 할 수 없음

-- 뷰 수정
-- 뷰 수정은 안됨
--> 뷰가 수정된다는 것은 삭제 후에 다시 생성되는 것
-- 하나만 추가한다고 해도 모든 컬럼 적어야 함
DESC TEST_CMP2;
CREATE OR REPLACE VIEW TEST_EMP5 AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, HIRE_DATE,
        JOB_ID, DEPARTMENT_ID FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50;

-- 문제) YEAR_SAL_VW 뷰를 만드시오
-- 사원번호, 성이름, 커미션 포함한 연봉, 직무, 부서번호 출력
CREATE OR REPLACE VIEW YEAR_SAL_VW
(E_ID, FULL_NAME, YEAR_SAL, J_ID, D_ID) AS
SELECT EMPLOYEE_ID, LAST_NAME || FIRST_NAME, (SALARY + (SALARY * NVL(COMMISSION_PCT, 0))) * 12,
        JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES;

SELECT * FROM YEAR_SAL_VW;

-- 문제) 각 부서의 부서명과 최소 급여, 최대 급여, 평균 급여, 부서명 출력
CREATE OR REPLACE VIEW GRP_VW(D_NAME, MIN_SAL, MAX_SAL, AVG_SAL) AS
SELECT D.DEPARTMENT_NAME, MIN(E.SALARY), MAX(E.SALARY), AVG(E.SALARY)
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY DEPARTMENT_NAME;

SELECT * FROM GRP_VW;

-- WITH CHECK OPTION
CREATE OR REPLACE VIEW EMPVU20 AS
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20;

SELECT * FROM EMPVU20;

INSERT INTO EMPVU20
VALUES (9988, 'Den', 'Rephealy', 'DRAPHEAL', '515.127.4561', '2021/05/19',
        'AC_ACCOUNT', 1000, NULL, 100, 80);
        
SELECT * FROM EMPLOYEES;

-- 문제) 뷰를 통해서 20인 부서만 보여진다면 다른 부서의 데이터는 저장되지 않게 
CREATE OR REPLACE VIEW EMPVU20_1 AS
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20
WITH CHECK OPTION CONSTRAINT EMPVU20_CK;

INSERT INTO EMPVU20_1
VALUES (9988, 'Den', 'Rephealy', 'DRAPHEAL', '515.127.4561', '2021/05/19',
        'AC_ACCOUNT', 1000, NULL, 100, 80);
-->  view WITH CHECK OPTION where-clause violation
--> 보이는 데이터만 저장할 수 있음

INSERT INTO EMPVU20_1
VALUES (9987, 'Den', 'Rephealy', 'DRAPHEAL', '515.127.4561', '2021/05/19',
        'AC_ACCOUNT', 1000, NULL, 100, 20);

SELECT * FROM EMPVU20_1;

-- READ ONLY
CREATE OR REPLACE VIEW EMPVU60 AS
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60
WITH READ ONLY;

INSERT INTO EMPVU60
VALUES (9987, 'Den', 'Rephealy', 'DRAPHEAL', '515.127.4561', '2021/05/19',
        'AC_ACCOUNT', 1000, NULL, 100, 60);
--> cannot perform a DML operation on a read-only view

SELECT * FROM EMPVU60;

-- VIEW 제거
DROP VIEW EMPVU60;

-- INLINE VIEW : FROM 절 안에 있는 SUBQUERY
SELECT * FROM(
    SELECT * FROM EMPLOYEES
    WHERE DEPARTMENT_ID = 50
);

-- 문제) 각 부서의 평균 급여와 같은 사원
-- 사원번호, 성, 급여, 부서번호, 평균 급여, 급여 출력
 SELECT EMPLOYEE_ID, LAST_NAME, SALARY, E.DEPARTMENT_ID, AVGSAL 
 FROM EMPLOYEES E, (
    SELECT DEPARTMENT_ID, AVG(SALARY) AVGSAL
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID) D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.SALARY = D.AVGSAL;

-- 문제) 각 부서에서 급여를 많이 받는 사원
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, E.DEPARTMENT_ID, MAXSAL 
FROM EMPLOYEES E, (
    SELECT DEPARTMENT_ID, MAX(SALARY) MAXSAL
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID) D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.SALARY = D.MAXSAL;

-- TOP N
-- 문제) 급여를 제일 많이 받는 사람 5명 출력
-- 사원번호, 이름, 급여, 부서, 직무
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, JOB_ID
FROM(SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, JOB_ID
     FROM EMPLOYEES
     WHERE SALARY IS NOT NULL
     ORDER BY SALARY DESC)
WHERE ROWNUM <= 5;
--> ROUNUM은 INLINE VIEW에만 있는 HIDDEN 컬럼

CREATE SEQUENCE DEPT_DEPTID_SEQ
INCREMENT BY 10
START WITH 300;

SELECT DEPT_DEPTID_SEQ.NEXTVAL, DEPT_DEPTID_SEQ.CURRVAL FROM DUAL;

-- DEPT_DEPTID_CURRVAL : 현재 부여된 값이 무엇인지 확인할 때 사용
SELECT DEPT_DEPTID_SEQ.CURRVAL FROM DUAL;

INSERT INTO EMPLOYEES
VALUES(DEPT_DEPTID_SEQ.NEXTVAL, 'Den', 'Raphely', 'DRAPHEAL', '515.127.4561', '2021/05/19',
        'AC_ACCOUNT', 1000, NULL, 100, 60);

SELECT * FROM EMPLOYEES;

-- SEQUENCE 수정
ALTER SEQUENCE DEPT_DEPTID_SEQ
INCREMENT BY 1
MAXVALUE 99999;
--> STARTVALUE는 수정 불가

DROP SEQUENCE DEPT_DEPTID_SEQ;

-- INDEX : 2 ~ 4% 정도가 효과 있음
CREATE INDEX EMP_EMAIL_IDX
ON EMPLOYEES(EMAIL);
--> EMAIL에 INDEX 생성

DROP INDEX EMP_EMAIL_IDX;

SELECT * FROM EMPLOYEES
WHERE EMAIL = 'SKING';

-- 문제) DOCONNEL ~ EBATES
SELECT * FROM EMPLOYEES
WHERE EMAIL BETWEEN 'DOCONNEL' AND 'EBATES';
--> INDEX는 SELECT할 때 자동으로 실행 됨

SELECT * FROM DEPARTMENTS
WHERE UPPER(DEPARTMENT_NAME) = 'SALES';

CREATE INDEX UPPER_INDEX
ON DEPARTMENTS(UPPER(DEPARTMENT_ID));
