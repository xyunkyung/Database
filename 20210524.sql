CREATE TABLE DEPT80 AS
SELECT * FROM HR.DEPARTMENTS
WHERE DEPARTMENT_ID = 80;

DESC DEPT80;

ALTER TABLE DEPT80
ADD (JOB_ID VARCHAR2(9));

DESC DEPT80;

CREATE TABLE EMP80 AS
SELECT * FROM HR.EMPLOYEES
WHERE 1 = 2;    -- 특정 테이블의 구조만 복사할 때

DESC EMP80;

ALTER TABLE EMP80
MODIFY (LAST_NAME VARCHAR2(30));

DESC EMP80;

DESC DEPT80;

ALTER TABLE DEPT80
DROP (JOB_ID);
--> 열에 데이터가 있어도 없어도 가능

DESC DEPT80;

CREATE TABLE EMPLOYEES(
    EMPLOYEE_ID NUMBER,
    FIRST_NAME VARCHAR2(20) NOT NULL,
    LAST_NAME VARCHAR2(25) NOT NULL,
    EMAIL VARCHAR2(25) CONSTRAINT EMP_NAMIL_UK UNIQUE,
    HIRE_DATE DATE DEFAULT SYSDATE,
    JOB_ID VARCHAR2(10),
    SALARY NUMBER(8, 2),
    COMMISSION_PCT NUMBER(2, 2),
    MANAGER_ID NUMBER(6),
    DEPARTMENT_ID NUMBER(4),
    CONSTRAINT EMP_EMPLOYEE_ID_PK PRIMARY KEY(EMPLOYEE_ID),
    CONSTRAINT EMP_SALARY_CK CHECK (SALARY > 0)
);

DROP TABLE EMPLOYEES;

CREATE TABLE EMPLOYEES AS
SELECT * FROM HR.EMPLOYEES
WHERE 1 = 2;

DESC EMPLOYEES;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';

-- 열 레벨
ALTER TABLE EMPLOYEES
MODIFY EMPLOYEE_ID NUMBER(6) CONSTRAINT EMP_EMPLOYEE_ID_PK PRIMARY KEY;

-- CONSTRAINT 삭제
ALTER TABLE EMPLOYEES
DROP CONSTRAINT EMP_EMPLOYEE_ID_PK;

-- 테이블 레벨
ALTER TABLE EMPLOYEES
ADD CONSTRAINT EMP_EMPLOYEE_ID_PK PRIMARY KEY(EMPLOYEE_ID);

CREATE TABLE DEPARTMENTS AS
SELECT * FROM HR.DEPARTMENTS
WHERE 1= 2;

DESC DEPARTMENTS;

ALTER TABLE DEPARTMENTS
ADD CONSTRAINT DEP_DEPTMENT_ID_PK PRIMARY KEY(DEPARTMENT_ID);

ALTER TABLE EMPLOYEES
MODIFY DEPARTMENT_ID CONSTRAINT EMP_DEPARTMENT_ID_FK REFERENCES DEPARTMENTS(DEPARTMENT_ID);

ALTER TABLE EMPLOYEES
DROP CONSTRAINT EMP_DEPARTMENT_ID_FK;

ALTER TABLE EMPLOYEES
ADD CONSTRAINT EMP_DEPARTMENT_ID_FK FOREIGN KEY(DEPARTMENT_Id) REFERENCES DEPARTMENTS(DEPARTMENT_ID);

ALTER TABLE EMPLOYEES
ADD CONSTRAINT EMP_MANAGER_ID_FK FOREIGN KEY(MANAGER_ID) REFERENCES EMPLOYEES(EMPLOYEE_ID);

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME =  'DEPARTMENTS';

ALTER TABLE DEPARTMENTS
DROP CONSTRAINT DEP_MANAGER_ID_FK;

ALTER TABLE EMPLOYEES
DROP CONSTRAINT EMP_MANAGER_ID_FK;

-- 식별관계
ALTER TABLE EMPLOYEES
ADD CONSTRAINT EMP_MANAGER_ID_FK FOREIGN KEY(MANAGER_ID) REFERENCES EMPLOYEES(EMPLOYEE_ID) ON DELETE CASCADE;

-- 비식별관계
ALTER TABLE EMPLOYEES
ADD CONSTRAINT EMP_MANAGER_ID_FK FOREIGN KEY(MANAGER_ID) REFERENCES EMPLOYEES(EMPLOYEE_ID) ON DELETE SET NULL;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'EMPLOYEES';

-- 1. 테이블 생성
CREATE TABLE MEMBER(
    MEMBER_NO VARCHAR2(15) NOT NULL,
    MEMBER_NAME VARCHAR2(20) NOT NULL,
    MEMBER_ID VARCHAR2(12) NOT NULL,
    MEMBER_PHONE VARCHAR2(30) NOT NULL,
    MEMBER_EMAIL VARCHAR2(40),
    MAMBER_MOBILE VARCHAR2(30),
    PAY_METHOD VARCHAR2(16)
);

CREATE TABLE ORDER1(
    ORDER_NO NUMBER NOT NULL,
    DEL_ADDR VARCHAR2(50) NOT NULL,
    DEL_PHONE VARCHAR2(30) NOT NULL,
    ORDER_DATE DATE NOT NULL,
    DEL_CODE NUMBER(6,3) NOT NULL,
    PAYMENT NUMBER(6,3) NOT NULL,
    TOT_PAYMENT INTEGER,
    MEMBER_NO VARCHAR2(15),
    QTY INTEGER
);

CREATE TABLE ORDER_LIST(
    ORDER_NO NUMBER NOT NULL,
    BOOK_NO NUMBER NOT NULL,
    ORDER_QTY NUMBER
);

CREATE TABLE BOOK(
    BOOK_NO NUMBER NOT NULL,
    BOOK_NAME VARCHAR2(20),
    BOOK_CK NUMBER(6,3),
    BOOK_QTY INTEGER
);

CREATE TABLE CHK_BOOK(
    CHK_NO INTEGER NOT NULL,
    MEMBER_NO VARCHAR2(15) NOT NULL,
    BOOK_NO NUMBER NOT NULL,
    REG_DATE DATE NOT NULL
);

CREATE TABLE PUBLISHER(
    PUB_CO_NUM VARCHAR2(15) NOT NULL,
    PUB_NAME VARCHAR2(20) NOT NULL,
    PUB_ADDR VARCHAR2(50) NOT NULL,
    PUB_PHONE VARCHAR2(30) NOT NULL,
    BANK_NO VARCHAR2(7) NOT NULL,
    ACCOUNT_NUM VARCHAR2(16) NOT NULL
);

CREATE TABLE CONTRACT_COMPANY(  
    CONT_NUMBER NUMBER NOT NULL,
    CONT_STATUS INTEGER NOT NULL,
    MIN_PCT NUMBER(6,3) NOT NULL,
    CONT_DATE DATE NOT NULL,
    PUB_CO_NUM VARCHAR2(15)
);

CREATE TABLE SUPPLY_BOOK(
    BOOK_NO NUMBER NOT NULL,
    CONT_NUMBER NUMBER NOT NULL,
    BOOK_REG DATE NOT NULL
);

-- 2. PRIMARY KEY
ALTER TABLE MEMBER
ADD CONSTRAINT MEM_MEMBER_NO_PK PRIMARY KEY(MEMBER_NO);

ALTER TABLE CHK_BOOK
ADD CONSTRAINT CHKBOOK_NO_PK PRIMARY KEY(CHK_NO, MEMBER_NO, BOOK_NO);

ALTER TABLE ORDER1
ADD CONSTRAINT ORDER1_ORDER_NO_PK PRIMARY KEY(ORDER_NO);

ALTER TABLE ORDER_LIST
ADD CONSTRAINT ORLST_ORDER_BOOK_NO_PK PRIMARY KEY(ORDER_NO, BOOK_NO);

ALTER TABLE BOOK
ADD CONSTRAINT BOOK_BOOK_NO_PK PRIMARY KEY(BOOK_NO);

ALTER TABLE PUBLISHER
ADD CONSTRAINT PUB_CO_NO_PK PRIMARY KEY(PUB_CO_NUM);

ALTER TABLE CONTRACT_COMPANY
ADD CONSTRAINT CON_CONT_NUMBER_PK PRIMARY KEY(CONT_NUMBER);

ALTER TABLE SUPPLY_BOOK
ADD CONSTRAINT SUP_BOOK_NO_CONT_NUMBER_PK PRIMARY KEY(BOOK_NO, CONT_NUMBER);

-- 3. FOREIGN KEY
ALTER TABLE ORDER1
ADD CONSTRAINT ORDER1_MEMBER_NO_FK FOREIGN KEY(MEMBER_NO)
REFERENCES MEMBER(MEMBER_NO) ON DELETE SET NULL;

ALTER TABLE ORDER_LIST
ADD CONSTRAINT ORLST_ORDER_NO_FK FOREIGN KEY(ORDER_NO)
REFERENCES ORDER1(ORDER_NO)ON DELETE CASCADE;

ALTER TABLE ORDER_LIST
ADD CONSTRAINT ORLST_BOOK_NO_FK FOREIGN KEY(BOOK_NO)
REFERENCES BOOK(BOOK_NO) ON DELETE CASCADE;

ALTER TABLE CONTRACT_COMPANY
ADD CONSTRAINT CON_CO_PUB_CO_NUM_FK FOREIGN KEY(PUB_CO_NUM)
REFERENCES PUBLISHER(PUB_CO_NUM) ON DELETE SET NULL;

ALTER TABLE SUPPLY_BOOK
ADD CONSTRAINT SUP_BOOK_NO_FK FOREIGN KEY(BOOK_NO)
REFERENCES BOOK(BOOK_NO) ON DELETE CASCADE;

ALTER TABLE SUPPLY_BOOK
ADD CONSTRAINT SUP_CONT_NUMBER_FK FOREIGN KEY(CONT_NUMBER)
REFERENCES CONTRACT_COMPANY(CONT_NUMBER) ON DELETE CASCADE;

ALTER TABLE CHK_BOOK
ADD CONSTRAINT CHB_MEMBER_NO_FK FOREIGN KEY(MEMBER_NO)
REFERENCES MEMBER(MEMBER_NO) ON DELETE CASCADE;

ALTER TABLE CHK_BOOK
ADD CONSTRAINT CHB_BOOK_NO_FK FOREIGN KEY(BOOK_NO)
REFERENCES BOOK(BOOK_NO) ON DELETE CASCADE;


-- 1. TABLE 2. PRIMARY KEY, 3. FOREIGN KEY
-- 4. UNIGUE, CHECK
ALTER TABLE MEMBER
ADD CONSTRAINT MEM_EMAIL_UU UNIQUE(MEMBER_EMAIL);

ALTER TABLE ORDER1
ADD CONSTRAINT ORD_QTY_CK CHECK(QTY > 0);

-- 제약 조건 보기 CONSTRAINT_NAME, COLUMN_NAME

-- 문제) 각 부서별로 급여를 제일 많이 받는 사원
SELECT * FROM HR.EMPLOYEES
WHERE SALARY IN(SELECT MAX(SALARY) FROM HR.EMPLOYEES GROUP BY DEPARTMENT_ID);

SELECT * FROM HR.EMPLOYEES
WHERE (DEPARTMENT_ID, SALARY) IN(SELECT DEPARTMENT_ID, MAX(SALARY) FROM HR.EMPLOYEES GROUP BY DEPARTMENT_ID);

SELECT * FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IN(SELECT DEPARTMENT_ID
                       FROM HR.EMPLOYEES)
AND SALARY IN(SELECT MAX(SALARY)
              FROM HR.EMPLOYEES
              GROUP BY DEPARTMENT_ID);
              
-- 문제) EMPLOYEE_ID가 178또는 174인 사원의 관리자 및 부서와 같은 관리자 및 부서를 갖는 사원의 정보
-- 단, 178번과 174번은 출력하지 말 것
SELECT * FROM HR.EMPLOYEES
WHERE (MANAGER_ID, DEPARTMENT_ID) IN(SELECT MANAGER_ID, DEPARTMENT_ID 
                                     FROM HR.EMPLOYEES 
                                     WHERE EMPLOYEE_ID IN(178, 174)) 
AND EMPLOYEE_ID NOT IN(178, 174);

SELECT * FROM HR.EMPLOYEES
WHERE MANAGER_ID IN(SELECT MANAGER_ID FROM HR.EMPLOYEES
                    WHERE EMPLOYEE_ID IN(178, 174))
AND DEPARTMENT_ID IN(SELECT DEPARTMENT_ID FROM HR.EMPLOYEES
                     WHERE EMPLOYEE_ID IN(178,174))
AND EMPLOYEE_ID NOT IN(174, 178);


SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SUM(SALARY) OVER(ORDER BY SALARY
                                                         ROWS BETWEEN UNBOUNDED PRECEDING   -- 첫번째 행
                                                         AND UNBOUNDED FOLLOWING) TOTAL -- 마지막 행
FROM HR.EMPLOYEES;


-- 문제) EMPLOYEES 테이블의 첫 행부터 마지막 행 까지 직원 번호, 이름, 급여, 급여의 누적 합계를 출력
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SUM(SALARY) OVER(ORDER BY SALARY
                                                         ROWS BETWEEN UNBOUNDED PRECEDING
                                                         AND CURRENT ROW) TOTAL -- 현재 행
FROM HR.EMPLOYEES;

-- 문제) EMPLOYEES 테이블의 첫 행부터 마지막 행 까지 직원 번호, 이름, 급여, 급여의 합계를 현재 행부터 마지막 행 까지의 합
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SUM(SALARY) OVER(ORDER BY SALARY
                                                         ROWS BETWEEN CURRENT ROW
                                                         AND UNBOUNDED FOLLOWING) TOTAL
FROM HR.EMPLOYEES;


-- 순위 함수
-- 1. RANK()
-- 문제) 급여를 제일 많이 받는 사람부터 순위
-- 직무 별 급여의 순위를 출력
SELECT FIRST_NAME, SALARY, JOB_ID, RANK() OVER(ORDER BY SALARY DESC) ALL_RANK,
                                   RANK() OVER(PARTITION BY JOB_ID ORDER BY SALARY DESC) JOB_RANK
FROM HR.EMPLOYEES;

-- 2. DENSE_RANK()
SELECT FIRST_NAME, SALARY,
       RANK() OVER(ORDER BY SALARY DESC) ALL_RANK,
       DENSE_RANK() OVER(ORDER BY SALARY DESC) DENSE_RANK
FROM HR.EMPLOYEES;

-- ROW_NUMBER()
SELECT FIRST_NAME, SALARY,
       RANK() OVER(ORDER BY SALARY DESC) ALL_RANK,
       ROW_NUMBER() OVER(ORDER BY SALARY DESC) ROW_NUMBER
FROM HR.EMPLOYEES;

-- FIRST_VALUE
-- 문제) 각 부서에서 급여를 제일 많이 받는 사원의 정보
SELECT DEPARTMENT_ID, FIRST_NAME, SALARY, 
       FIRST_VALUE(JOB_ID) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC
                                    ROWS UNBOUNDED PRECEDING) AS DEPT_A
FROM HR.EMPLOYEES;

-- LAST_VALUE
SELECT DEPARTMENT_ID, FIRST_NAME, SALARY, 
       LAST_VALUE(FIRST_NAME) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC
                                    ROWS BETWEEN UNBOUNDED PRECEDING
                                    AND UNBOUNDED FOLLOWING) AS DEPT_A
FROM HR.EMPLOYEES;